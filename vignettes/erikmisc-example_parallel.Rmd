---
title: "Parallel processing examples"
subtitle: "future and foreach"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 5
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Parallel processing examples}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
knitr::opts_chunk$set(fig.height = 6, fig.width = 6)

library(erikmisc)
library(tidyverse)
```

# Examples

## Timing

```{r}
# install.packages("tictoc")
tictoc::tic(msg = "Timer")
tictoc::toc()
```


---

## Standard sequential solution

```{r}
# size of the problem
list_letters <- LETTERS[1:19]
n_sam <- 1e3
seconds_sleep <- 0.1

# function to compute
f_this_function <-
  function(
    n_letter  = "A"
  , n_sam     = 1e1
  , seconds_sleep = 1
  ) {
  dat_this <-
    tibble::tibble(
      sam1    = rnorm(n_sam)
    , sam2    = rnorm(n_sam)
    , letter  = n_letter
    )

  library(ggplot2)
  p <- ggplot(dat_this, aes(x = sam1, y = sam2))
  p <- p + theme_bw()
  p <- p + geom_point()

  Sys.sleep(seconds_sleep)

  out <-
    list(
      dat   = dat_this
    , plot  = p
    , pid   = Sys.getpid()
    )

  return(out)

} # f_this_function


tictoc::tic(msg = "Timer") # start timer

# prespecify the "results" list
results <- list()

for (i_letter in seq_along(list_letters)) {
  ## i_letter = 1
  n_letter <- list_letters[i_letter]

  results[[n_letter]] <-
    f_this_function(
      n_letter  = n_letter
    , n_sam     = n_sam
    , seconds_sleep = seconds_sleep
    )
}

tictoc::toc() # end timer
```

---

## future

* Works well for calling a function with output into lists

### Example: parallel single loop

```{r}
library(future)  # for %<-% operator

sw_parallel <- c("sequential", "multisession")[2]

if (sw_parallel == "sequential") {
  # 1 process
  future::plan(strategy = future::sequential)
  message(1, "cores for sequential")
}

if (sw_parallel == "multisession") {
  # parallel, separate R sessions, same machine (Windows)
  num_cores <- parallelly::availableCores(omit = 1)

  future::plan(
    strategy =
      future::multisession(
        workers = num_cores
      )
    )
  message(paste(num_cores, "cores for parallel"))
}


tictoc::tic(msg = "Timer") # start timer

# prespecify the "results" list using listenv::listenv(), not with list()
results <- listenv::listenv()  # list for parallel

for (i_letter in seq_along(list_letters)) {
  ## i_letter = 1
  n_letter <- list_letters[i_letter]

  results[[n_letter]] %<-%   # %<-% runs the process in future parallel
    f_this_function(
      n_letter  = n_letter
    , n_sam     = n_sam
    , seconds_sleep = seconds_sleep
    )
}

# Convert from listenv() to list() for a familiar object class
# For very big results, this can take a long time
#   and the indexing works similarly for listenv()
# results <-
#   results %>%
#   as.list()

tictoc::toc() # end timer

# Explicitly close multisession workers by switching plan
future::plan(strategy = future::sequential)

```

---

## foreach

### Example: parallel single loop

```{r}
library(doParallel)  # for %dopar% operator
num_cores <- parallel::detectCores() - 1
doParallel::registerDoParallel(num_cores)

tictoc::tic(msg = "Timer") # start timer

# don't prespecify the "results" list

results <-
  foreach::foreach(
    i_letter = seq_along(list_letters)
  #, .combine =                             # default is a list
  , .inorder = TRUE                         # FALSE is faster
  , .packages = c("erikmisc", "tidyverse")  # character vector of packages that the tasks depend on
  , .export = NULL                          # character vector of variables to export
  #) %do% # sequential
  ) %dopar%  # parallel
  {
  ## i_letter = 1
  n_letter <- list_letters[i_letter]


  #results[[n_letter]] <-
  out <-
    f_this_function(
      n_letter  = n_letter
    , n_sam     = n_sam
    , seconds_sleep = seconds_sleep
    )

  # use a return value
  return( out )

} # foreach

tictoc::toc() # end timer

# explicitly close the implicitly created cluster
doParallel::stopImplicitCluster()
```


### Example: nested sequential outer loop, parallel inner loop

```{r}
library(doParallel)  # for %dopar% operator
num_cores <- parallel::detectCores() - 1
doParallel::registerDoParallel(num_cores)

tictoc::tic(msg = "Timer") # start timer

# prespecify outer "results" list
results <- list()

for (i_num in 1:10) {

  # don't prespecify inner results[[ i ]] list

  results[[i_num]] <-
    foreach::foreach(
      i_letter = seq_along(list_letters)
    #, .combine =                             # default is a list
    , .inorder = TRUE                         # FALSE is faster
    , .packages = c("erikmisc", "tidyverse")  # character vector of packages that the tasks depend on
    , .export = NULL                          # character vector of variables to export
    #) %do% # sequential
    ) %dopar%  # parallel
    {
    ## i_letter = 1
    n_letter <- list_letters[i_letter]


    #results[[n_letter]] <-
    out <-
      f_this_function(
        n_letter  = n_letter
      , n_sam     = n_sam
      , seconds_sleep = seconds_sleep
      )

    # use a return value
    return( out )

  } # foreach

} # i_num

tictoc::toc() # end timer

# explicitly close the implicitly created cluster
doParallel::stopImplicitCluster()
```


### Example: nested parallel outer loop, sequential inner loop


```{r}
library(doParallel)  # for %dopar% operator
num_cores <- parallel::detectCores() - 1
doParallel::registerDoParallel(num_cores)

tictoc::tic(msg = "Timer") # start timer

# don't prespecify outer "results" list

results <-
  foreach::foreach(
    i_letter = seq_along(list_letters)
  #, .combine =                             # default is a list
  , .inorder = TRUE                         # FALSE is faster
  , .packages = c("erikmisc", "tidyverse")  # character vector of packages that the tasks depend on
  , .export = NULL                          # character vector of variables to export
  #) %do% # sequential
  ) %dopar%  # parallel
  {

  this_result <- list()

  for (i_num in 1:10) {

  # don't prespecify inner list

    ## i_letter = 1
    n_letter <- list_letters[i_letter]

    #results[[n_letter]] <-
    this_result[[ i_num ]] <-
      f_this_function(
        n_letter  = n_letter
      , n_sam     = n_sam
      , seconds_sleep = seconds_sleep
      )

    this_result[[ i_num ]][[ "i_num" ]] <- i_num

  } # i_num

  return(this_result)

} # foreach

tictoc::toc() # end timer

# explicitly close the implicitly created cluster
doParallel::stopImplicitCluster()
```

